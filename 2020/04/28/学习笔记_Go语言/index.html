<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.1.2",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script></script><meta name="keywords" content="学习笔记,go"><meta property="og:type" content="article"><meta property="og:title" content="GoLang学习笔记"><meta property="og:url" content="https://robotwuyun.github.io/2020/04/28/学习笔记_Go语言/index.html"><meta property="og:site_name" content="但行好事,莫问前程"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2020-06-12T09:17:01.056Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="GoLang学习笔记"><link rel="canonical" href="https://robotwuyun.github.io/2020/04/28/学习笔记_Go语言/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>GoLang学习笔记 | 但行好事,莫问前程</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><script type="text/javascript" src="/js/src/clicklove.js"></script><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/RobotWuYun" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">但行好事,莫问前程</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">记录学习的技能和遇到的问题</p></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://robotwuyun.github.io/2020/04/28/学习笔记_Go语言/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="上课睡觉觉"><meta itemprop="description" content="keep learning"><meta itemprop="image" content="/image/headPic.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="但行好事,莫问前程"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">GoLang学习笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-04-28 14:53:13" itemprop="dateCreated datePublished" datetime="2020-04-28T14:53:13+08:00">2020-04-28</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-06-12 17:17:01" itemprop="dateModified" datetime="2020-06-12T17:17:01+08:00">2020-06-12</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">评论数：</span><a href="/2020/04/28/学习笔记_Go语言/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/04/28/学习笔记_Go语言/" itemprop="commentCount"></span></a></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i> 热度：<span class="busuanzi-value" id="busuanzi_value_page_pv"></span> <span>℃</span></span></div></header><div class="post-body" itemprop="articleBody"><center></center><a id="more"></a><h3 id="Go语言的起源"><a href="#Go语言的起源" class="headerlink" title="Go语言的起源"></a>Go语言的起源</h3><p>为什么要创造Go语言?</p><ol><li>计算机硬件技术更新频繁,性能提高很快.目前主流的编程语言落后于硬件,不能合理利用<strong>多核多CPU</strong>的优势.</li><li>软件系统复杂度越来越高,维护成本越来越高,目前<strong>缺乏一个足够简洁高效</strong>的百年城语言</li><li>c/c++由内存泄漏等遗留问题</li></ol><p>So:</p><p>继承了多种语言特性为了符合现代编程思想而诞生的新的编程语言.</p><ul><li><p>C的基础</p><blockquote><p>表达式语法,控制流结构,基础数据类型.调用参数传值,指针等很多思想,和C语言一致所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配.</p><p>所以Go语言,又被称为”C类似语言”,或者”21世纪的C语言”.</p></blockquote></li><li><p>Pascal语言</p><blockquote><p>Modula-2语言激发了包的概念</p><p>Oberon语言摒弃了模块接口文件和模块实现文件之间的区别.</p><p>第二代Oberon-2语言直接影响了包的导入和声明的语法,还有Oberon语言的面向对象特性所提供的方法的声明语法等.</p></blockquote></li><li><p>CSP(<em>顺序通信进程</em> communicating sequential processes)</p><blockquote><p>在CSP中,程序是一组中间没有共享状态的平行运行的处理过程,它们之间<strong>使用管道进行通信和控制同步.</strong></p></blockquote></li><li><p>等等</p></li></ul><h3 id="Go语言特点"><a href="#Go语言特点" class="headerlink" title="Go语言特点"></a>Go语言特点</h3><ul><li><p>所有编程语言都反映了语言设计者对编程哲学的反思,通常包括之前的语言所暴露的一些不足地方的改进.(具有动态语言的简洁和高效,也有静态语言的安全和性能,垃圾回收)</p><blockquote><p>Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思。</p></blockquote></li><li><p>用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。(向后兼容)</p></li><li><p>天然并发(重要特点)</p></li><li><p>管道通信机制</p></li><li><p>鼓励当代计算机系统设计的原则,特别是局部的重要性.</p></li><li><p>不论是基础数据类型还是聚合类型都十分方便,简洁,效率</p></li><li><p>提供了基于CSP的并发特性支持.</p></li><li><p>大量库支持</p></li><li><p>数据处理,处理大并发厉害</p></li><li><p>函数可以返回多个值</p></li></ul><h3 id="GoLang的学习方向"><a href="#GoLang的学习方向" class="headerlink" title="GoLang的学习方向"></a>GoLang的学习方向</h3><p>GoLang(GoLanguage).</p><ul><li>区块链研发工程师</li><li>Go服务器端/游戏软件工程师</li><li>GoLang分布式/云计算软件工程师</li></ul><h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><ul><li>区块链应用</li><li>后端服务器应用(计算能力强,强大的处理大并发的能力)</li><li>云计算和云服务应用</li></ul><blockquote><p><strong>如何快速学习一个新的知识和新的技术?</strong></p><ul><li>我们有一个新的需求</li><li>现有的技术能不能解决这个问题</li><li>用新框架解决或学习新技术</li><li>快速入门(原理,基本语法)</li><li>讨论技术细节(怎么规范,使用陷阱,使用时注意什么)</li></ul></blockquote><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><table><thead><tr><th align="center">环境变量</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">GOROOT</td><td align="center">指定SDK的安装路径</td></tr><tr><td align="center">Path</td><td align="center">添加SDK的/bin目录</td></tr><tr><td align="center">GOPATH</td><td align="center">工作目录,将来我们的go项目的工作路径</td></tr></tbody></table><h3 id="Go语言快速入门"><a href="#Go语言快速入门" class="headerlink" title="Go语言快速入门"></a>Go语言快速入门</h3><p>Go语言的基础组成有以下几个部分:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前程序的包名</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入其他包</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量的声明和赋值</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"gopher"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般类型声明</span></span><br><span class="line"><span class="keyword">type</span> newType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构的声明</span></span><br><span class="line"><span class="keyword">type</span> gopher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的声明</span></span><br><span class="line"><span class="keyword">type</span> golang <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由main函数作为程序入口点启动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Go 程序是通过 <strong>package</strong> 来组织的。</p></li><li><p>只有 package 名称为 main 的源码文件可以包含 main 函数。</p></li><li><p>一个可执行程序有且仅有一个 <strong>main</strong> 包。</p></li><li><p>通过 <strong>import</strong> 关键字来导入其他非 <strong>main</strong> 包。</p></li><li><p>可以通过 <strong>import</strong> 关键字单个导入:</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br></pre></td></tr></table></figure><p>也可以同时导入多个:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(math.Exp2(<span class="number">10</span>))  <span class="comment">// 1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>&lt;PackageName&gt;.&lt;FunctionName&gt;</code> 调用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 别名：</span><br><span class="line"><span class="comment">// 为fmt起别名为fmt2</span></span><br><span class="line"><span class="keyword">import</span> fmt2 <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure><p>省略调用(不建议使用):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的时候只需要Println()，而不需要fmt.Println()</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure><p>前面加个点表示省略调用，那么调用该模块里面的函数，可以不用写模块名称了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Println(<span class="string">"hello,world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <strong>const</strong> 关键字来进行常量的定义。</p><p>通过在函数体外部使用 <strong>var</strong> 关键字来进行全局变量的声明和赋值。</p><p>通过 <strong>type</strong> 关键字来进行结构(struct)和接口(interface)的声明。</p><p>通过 <strong>func</strong> 关键字来进行函数的声明。</p><p><strong>可见性规则</strong></p><p>Go语言中，使用大小写来决定该常量、变量、类型、接口、结构或函数是否可以被外部包所调用。</p><p>函数名首字母小写即为 <strong>private</strong> :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getId</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>函数名首字母大写即为 <strong>public</strong> :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是我的第一个go程序 */</span></span><br><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>go文件的后缀是.go</p></li><li><p><code>package main</code>表示该文件所在的包是main,在go中,每个文件都必须属于一个包.</p><blockquote><ul><li><p>文件名和包名没有直接关系不一定要将文件名于包名定成同一个</p></li><li><p>文件夹名与包名没有直接关系,并非需要一致</p></li><li><p>同一个文件夹下文件只能由一个包名,否则编译报错.</p></li></ul></blockquote></li><li><p><code>import &quot;fmt&quot;</code>表示引入一个包,包名fmt,引入该包后,就可以使用fmt包的函数.</p></li><li><p><code>func main(){}</code>中<code>func</code>是一个关键字,表示一个函数,<code>main</code>是函数名,是一个主函数,即我们程序的入口.</p></li><li><p><code>fmt.Println(&quot;hello&quot;)</code>表示调用fmt包的函数Println输出”hello”.</p></li><li><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</p></li></ol><blockquote><p><strong>注意:</strong><code>{</code>不能在单独的行上</p></blockquote><p>编写完代码,我们开始执行,在执行前我们需要先对go代码进行编译:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build hello.go</span><br></pre></td></tr></table></figure><p>在终端中运行该代码,即可将go源码编译为可执行文件(hello.exe),之后便是运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.exe</span><br></pre></td></tr></table></figure><p>或者,我们可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>直接编译运行.</p><blockquote><p><strong>两种执行流程的方式区别:</strong></p><ol><li>如果我们先编译生成可执行文件,那么我们可以将该可执行文件拷贝到没有go开发环境的机器上,让仍然可以运行</li><li>如果我们直接编译运行(<code>go run</code>)源代码,那么如果要在另一个机器上这么运行,也需要go开发环境,否则无法执行.</li><li>在编译时,编译会将程序运行依赖的库文件包含在可执行文件中,所以,可执行文件变大了很多.</li></ol></blockquote><h3 id="Go程序开发注意事项"><a href="#Go程序开发注意事项" class="headerlink" title="Go程序开发注意事项"></a>Go程序开发注意事项</h3><ol><li>Go源文件以<code>go</code>为扩展名</li><li>Go应用程序的执行入口是main()函数.</li><li>Go语言严格区分大小写</li><li>Go方法由一条条语句构成,每个语句后不需要分号(Go语言会自动在每行后面添加分号)</li><li>Go编译器是一行行进行编译的,因此我们一行就写一条语句,不能把多条语句写在统一行.</li><li>Go定义变量或imorty的包如果没有使用过,代码不能通过编译.</li></ol><h3 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h3><h4 id="Go标记"><a href="#Go标记" class="headerlink" title="Go标记"></a>Go标记</h4><p>Go程序可以由多个标记组成,可以是关键字,标识符,常量,字符串,符号.</p><h4 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h4><p>当你打算将多个语句写在同一行,它们则必须使用<code>;</code>但在实际开发中不鼓励这种做法.</p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符用来命名变量,类型等程序实体.一个标识符实际上就是一个或多个字母(A<del>Z和a</del>z)数字(0~9),下划线组成的序列,但是<strong>第一个字符必须是字母或下划线而不能是数字</strong>,切不能和Go语言关键词一样.</p><h4 id="字符串链接"><a href="#字符串链接" class="headerlink" title="字符串链接"></a>字符串链接</h4><p>Go语言的字符串可以通过<code>+</code>实现.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Google"</span>+<span class="string">"Runoob"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Go语言的空格"><a href="#Go语言的空格" class="headerlink" title="Go语言的空格"></a>Go语言的空格</h4><p>Go语言中的变量的声明必须使用空格隔开,如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><p>语句中适当使用空格可以能让程序更易阅读.</p><h3 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h3><p>在Go语言中,数据类型用于声明函数和变量.</p><p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td></tr><tr><td align="left">2</td><td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td></tr><tr><td align="left">3</td><td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td></tr><tr><td align="left">4</td><td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td></tr></tbody></table><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td align="left">2</td><td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td align="left">3</td><td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td align="left">4</td><td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td align="left">5</td><td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td align="left">6</td><td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td align="left">7</td><td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="left">8</td><td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h5 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h5><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td align="left">2</td><td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td align="left">3</td><td align="left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td align="left">4</td><td align="left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table><h5 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h5><p>以下列出了其他更多的数字类型：</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>byte</strong> 类似 uint8</td></tr><tr><td align="left">2</td><td align="left"><strong>rune</strong> 类似 int32</td></tr><tr><td align="left">3</td><td align="left"><strong>uint</strong> 32 或 64 位</td></tr><tr><td align="left">4</td><td align="left"><strong>int</strong> 与 uint 一样大小</td></tr><tr><td align="left">5</td><td align="left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td></tr></tbody></table><blockquote><p>go 1.9版本对于数字类型,无需定义int及float32,float64,系统会自动识别.</p></blockquote><h3 id="Go语言变量"><a href="#Go语言变量" class="headerlink" title="Go语言变量"></a>Go语言变量</h3><p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。</p><p>变量可以通过变量名访问。</p><p>Go 语言变量名<strong>由字母、数字、下划线组成，其中首个字符不能为数字</strong>。</p><p><strong>声明变量的一般形式是使用 var 关键字</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>可以一次声明多个变量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1, identifier2 <span class="keyword">type</span></span><br></pre></td></tr></table></figure><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p><strong>第一种,指定变量类型,如果没有初始化,则变量默认为零值.</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = v_type</span><br><span class="line">v_name = value</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>数值类型为0</p></li><li><p>布尔类型为false</p></li><li><p>字符串类型为””(空字符串)</p></li><li><p>以下几种类型为nil:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">&gt;   <span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line">&gt;   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span></span><br><span class="line">&gt;   <span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&gt;   <span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">&gt;   <span class="title">var</span> <span class="title">a</span> <span class="title">error</span> // <span class="title">error</span> 是接口</span></span><br><span class="line"><span class="function">&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>第二种,根据值自行判断变量类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = value</span><br></pre></td></tr></table></figure><p><strong>第三种,省略var,注意<code>:=</code>左侧如果没有声明新的变量,就产生编译错误</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_name := value</span><br></pre></td></tr></table></figure><h5 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h5><p>所有像int,float,bool和string这些基本类型都属于值类型,使用这些类型的变量直接指向存在内存中的值,值类型的变量的值存储载包栈中,内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存.一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。这个内存地址为称之为<strong>指针</strong>，这个指针实际上也被存在另外的某一个字中。同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p><h5 id="简短形式-使用-赋值操作符"><a href="#简短形式-使用-赋值操作符" class="headerlink" title="简短形式,使用:=赋值操作符"></a>简短形式,使用:=赋值操作符</h5><p>它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。</p><blockquote><p><strong>注意:</strong>如果在相同的代码中,我们不可以再次对于相同名称的变量使用初始化声明,编译器会提示错误<code>no new variables on left side of :=</code>.</p><p>如果你声明了一个局部变量却没有在相同的代码中使用它,同样会得到编译错误.此外，单纯地给 a 赋值也是不够的，这个值必须被使用，但是全局变量是允许声明但不使用。</p></blockquote><p>同一类型的多个变量可以声明在同一行，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>多变量可以在同一行进行赋值，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">string</span></span><br><span class="line">a, b, c = <span class="number">5</span>, <span class="number">7</span>, <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><p>上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c := <span class="number">5</span>, <span class="number">7</span>, <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><p>右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”。</p><p>这被称为 并行 或 同时 赋值。</p><p>如果你想要交换两个变量的值，则可以简单地使用 <strong>a, b = b, a</strong>，两个变量的类型必须是相同。</p><p>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。</p><p>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p><p>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)。</p><h3 id="Go语言常量"><a href="#Go语言常量" class="headerlink" title="Go语言常量"></a>Go语言常量</h3><p>常量是一个简单值的标识符,在程序运行时,不会被修改的量.</p><p>常量中的数据类型只可以是布尔型,数字型(整数型,浮点型和复数)和字符串型.</p><p>常量的定义格式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifiter [<span class="keyword">type</span>]  = value</span><br></pre></td></tr></table></figure><blockquote><p>可以省略类型说明符[type],因为编译器可以根据变量的值来推断其类型.</p></blockquote><p>多个相同类型的声明可以简写为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c_name1,c_name2 = value1,value2</span><br></pre></td></tr></table></figure><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>iota,特殊常量,可以认为是一个可以被编译器修改的常量.</p><p>iota在const关键字出现时将被重置为0(const内部的第一行之前),const中没新增一行常量声明将使iota计数一次(iota可以理解为const语句块中的行索引).</p><p>iota可以被用作枚举值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第一个iota等于0,每当iota在新的一行被使用时,它的值都会制动＋1;所以a=0,b=1,c=2可以简写为如下形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h3><p>运算符用于在程序运算时执行行数学或逻辑运算.</p><p>Go语言内置的运算符有:</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">相加</td></tr><tr><td align="left">-</td><td align="left">相减</td></tr><tr><td align="left">*</td><td align="left">相乘</td></tr><tr><td align="left">/</td><td align="left">相除</td></tr><tr><td align="left">%</td><td align="left">求余</td></tr><tr><td align="left">++</td><td align="left">自增</td></tr><tr><td align="left">–</td><td align="left">自减</td></tr></tbody></table><blockquote><p>Go的自增自减只能作为作为表达式使用,而不能用于赋值语句.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; a++ <span class="comment">//允许,类似于a = a + 1,结果于a++相同</span></span><br><span class="line">&gt; a-- <span class="comment">//与a++相似</span></span><br><span class="line">&gt; a = a++ <span class="comment">//不允许,会出现变异错误 syntax error: unexpected ++ at end of statement</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td align="left">!=</td><td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。</td></tr><tr><td align="left">||</td><td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。</td></tr><tr><td align="left">!</td><td align="left">逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。</td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td align="left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td align="left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td align="left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td><td align="left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr></tbody></table><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="left">+=</td><td align="left">相加后再赋值</td></tr><tr><td align="left">-=</td><td align="left">相减后再赋值</td></tr><tr><td align="left">*=</td><td align="left">相乘后再赋值</td></tr><tr><td align="left">/=</td><td align="left">相除后再赋值</td></tr><tr><td align="left">%=</td><td align="left">求余后再赋值</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移后赋值</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移后赋值</td></tr><tr><td align="left">&amp;=</td><td align="left">按位与后赋值</td></tr><tr><td align="left">^=</td><td align="left">按位异或后赋值</td></tr><tr><td align="left">|=</td><td align="left">按位或后赋值</td></tr></tbody></table><h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">返回变量存储地址</td><td align="left">&a; 将给出变量的实际地址。</td></tr><tr><td align="left">*</td><td align="left">指针变量。</td><td align="left">*a; 是一个指针变量</td></tr></tbody></table><blockquote><p>指针变量<code>*</code>和地址值<code>&amp;</code>的区别:指针变量保存的是一个地址值,会分配独立的内存来存储一个整型数字.当变量前面有<code>*</code>标识时,才等同于<code>&amp;</code>的用法,否则会直接输出一个整型数字.</p></blockquote><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td align="left">4</td><td align="left">+ - | ^</td></tr><tr><td align="left">3</td><td align="left">== != &lt; &lt;= &gt; &gt;=</td></tr><tr><td align="left">2</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">1</td><td align="left">||</td></tr></tbody></table><h3 id="Go语言条件语句"><a href="#Go语言条件语句" class="headerlink" title="Go语言条件语句"></a>Go语言条件语句</h3><p>Go语言提供了以下几种判断语句.</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句由一个布尔表达式后紧跟一个或多个语句组成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">    <span class="comment">/* 在布尔表达式为true时执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h4><p>if语句后可以使用可选的else语句.else语句中的表达式在布尔表达式围为false时执行.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">    <span class="comment">/* 在布尔表达式为true时执行*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if嵌套语句"><a href="#if嵌套语句" class="headerlink" title="if嵌套语句"></a>if嵌套语句</h4><p>可以在if或else if语句中嵌入一个或多个if或else if语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 <span class="number">1</span> &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式 1 为 true 时执行 */</span></span><br><span class="line">   <span class="keyword">if</span> 布尔表达式 <span class="number">2</span> &#123;</span><br><span class="line">      <span class="comment">/* 在布尔表达式 2 为 true 时执行 */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。</p><p>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。</p><p>switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 <strong>fallthrough</strong> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h5><p>switch语句还可以被用于type-switch来判断某个interface变量中实际存储的变量类型.</p><p>Type Switch语法格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h5><p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"1、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">"2、case 条件语句为 true"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"3、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">"4、case 条件语句为 true"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"5、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"6、默认 case"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h4><p>select语句类似于switch语句,但是select会随机执行一个可运行的case.如果没有case可运行,它将阻塞,直到有case可运行.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下描述了 select 语句的语法：</p><ul><li><p>每个 case 都必须是一个通信</p></li><li><p>所有 channel 表达式都会被求值</p></li><li><p>所有被发送的表达式都会被求值</p></li><li><p>如果任意某个通信可以进行，它就执行，其他被忽略。</p></li><li><p>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。</p><p>否则：</p><ol><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ol></li></ul><blockquote><p>注意Go语言没有三目运算符,所以不支持<code>?:</code>形式的判断.</p></blockquote><h3 id="Go语言循环语句"><a href="#Go语言循环语句" class="headerlink" title="Go语言循环语句"></a>Go语言循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>重复执行语句块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> init;condition;post &#123; &#125;	<span class="comment">//和c的for一样</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123; &#125;			<span class="comment">//和c的while一样</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ()						<span class="comment">//和c的for(;;)一样</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>init： 一般为赋值表达式，给控制变量赋初值；</li><li>condition： 关系表达式或逻辑表达式，循环控制条件；</li><li>post： 一般为赋值表达式，给控制变量增量或减量。</li><li>for语句的执行过程如下:<ol><li>先对表达式 1 赋初值；</li><li>判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</li></ol></li></ul></blockquote><p>for循环的range格式可以对slice,map,数组,字符串等进行迭代循环.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>在for循环中嵌套一个或多个for循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">   &#123;</span><br><span class="line">      statement(s);</span><br><span class="line">   &#125;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h4><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><p>Go 语言中 break 语句用于以下两方面：</p><ul><li>用于循环语句中跳出循环，并开始执行循环之后的语句。</li><li>break 在 switch（开关语句）中在执行一条 case 后跳出语句的作用。</li><li>在多重循环中，可以用标号 label 标出想 break 的循环。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h5 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h5><p>跳过当前循环剩下的语句,然后继续进行下一轮循环.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h5 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h5><p>Go 语言的 goto 语句可以无条件地转移到过程中指定的行。</p><p>goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p><p>但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure><h5 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span>  &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"这是无限循环。\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言函数"><a href="#Go语言函数" class="headerlink" title="Go语言函数"></a>Go语言函数</h3><blockquote><p>注意:在go中,首字母小写表示私有,其他包的函数不能调用.所以需要时将首字母大写–该函数可导出.</p><p>同一个包下不允许有同名函数</p></blockquote><p>函数是基本的代码块,用于执行一个任务.</p><p>Go语言最少有一 个main()函数</p><p>你可以同函数函数来话费不同的gonngnb,罗计算狗每个函数执行的是指定任务.</p><p>函数声明告诉了编译器函数的名字,返回类型和参数.</p><p>Go 语言标准库提供了多种可动用的内置的函数.</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func function_name( [parameter list] ) [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义解析：</p><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><h4 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">"Google"</span>, <span class="string">"Runoob"</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p><p>形参就像定义在函数体内的局部变量。</p><p>调用函数，可以通过两种方式来传递参数：</p><table><thead><tr><th align="left">传递类型</th><th align="left">描述</th><th>栗子</th></tr></thead><tbody><tr><td align="left">传递</td><td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td><td><code>func swap(x, y int) int {}</code></td></tr><tr><td align="left">引用传递</td><td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td><td><code>func swap(x *int, y *int) {}</code></td></tr></tbody></table><p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><h4 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h4><table><thead><tr><th align="left">函数用法</th><th align="left">描述</th><th>例</th></tr></thead><tbody><tr><td align="left">函数作为另外一个函数的实参</td><td align="left">函数定义后可作为另外一个函数的实参数传入</td><td><code>fmt.Println(getSquareRoot(9))</code></td></tr><tr><td align="left">闭包</td><td align="left">闭包是匿名函数，可在动态编程中使用</td><td>`func getSequence() func() int {<br> i:=0<br> <strong>return</strong> func() int {<br> i+=1<br> <strong>return</strong> i<br> }<br>}</td></tr><tr><td align="left">方法</td><td align="left">方法就是一个包含了接受者的函数</td><td><code>func (variable_name variable_data_type) function_name() [return_type]{ /* 函数体*/ }</code></td></tr></tbody></table><h3 id="Go语言变量作用域"><a href="#Go语言变量作用域" class="headerlink" title="Go语言变量作用域"></a>Go语言变量作用域</h3><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p><p>Go 语言中变量可以在三个地方声明：</p><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在函数体内声明的变量称之为局部变量,它们的作用域值在函数体内,参数和返回值变量也是局部变量.</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。</p><blockquote><p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。</p></blockquote><h4 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明全局变量 */</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* main 函数中声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"main()函数中 a = %d\n"</span>,  a);</span><br><span class="line">   c = sum( a, b);</span><br><span class="line">   fmt.Printf(<span class="string">"main()函数中 c = %d\n"</span>,  c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数定义-两数相加 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"sum() 函数中 a = %d\n"</span>,  a);</span><br><span class="line">   fmt.Printf(<span class="string">"sum() 函数中 b = %d\n"</span>,  b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化局部和全局变量"><a href="#初始化局部和全局变量" class="headerlink" title="初始化局部和全局变量"></a>初始化局部和全局变量</h4><p>不同类型的局部和全局变量默认值为：</p><table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">float32</td><td align="left">0</td></tr><tr><td align="left">pointer</td><td align="left">nil</td></tr></tbody></table><p>可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。</p><h3 id="Go语言数组"><a href="#Go语言数组" class="headerlink" title="Go语言数组"></a>Go语言数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>Go语言数组声明需要指定元素类型及元素个数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure><h4 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>,<span class="number">2.0</span>,<span class="number">3.4</span>,<span class="number">7.0</span>,<span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure><p>初始化数组中{}的元素个数不能大于[]中的数字.</p><p>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> salary <span class="keyword">float32</span> = balance[<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>Go 语言支持多维数组，以下为常用的多维数组声明方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br></pre></td></tr></table></figure><h5 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,   <span class="comment">/* 第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中倒数第二行的 <strong>}</strong> 必须要有逗号，因为最后一行的 <strong>}</strong> 不能单独一行,也可以写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;   <span class="comment">/* 第三行索引为 2 */</span></span><br></pre></td></tr></table></figure><h4 id="向函数传递数组"><a href="#向函数传递数组" class="headerlink" title="向函数传递数组"></a>向函数传递数组</h4><p><strong>方式一</strong></p><p>形参设定数组大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myFunction(param [<span class="number">10</span>]<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><p>形参未设定数组大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myFunction(param []<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h3><blockquote><ul><li><p>32位操作系统的最大虚拟空间为2的32次方,4G.在最后最后1/4为kernel(内核区)当前操作系统的操作部分,剩下的部分叫做user(用户区),其包含了.text(代码区),.rodata(只读数据区),.data(数据区),.bss(未初始化数据区),heap(堆),共享数据区和stack(栈)</p></li><li><p>数据可以存在栈,堆,数据区,未初始化数据区</p></li><li><p>栈帧:给函数运行提供运行空间,取内存于stack上,当函数调用时,产生栈帧.函数调用结束栈帧释放,栈帧存储:1.局部变量,2.形参(形参与局部变量存储地位相同),3.内存字段描述值</p></li><li><p>在内存中机器用通过栈顶指针和栈基指针来确定当前执行的函数,以及用其差值计算函数占用的内存空间,当发生函数内调用时,两个指针同时上移,并将旧的指针记录在旧的函数内,这个记录称之为内存字段描述值.</p></li><li><p>指针在索引和赋值是必须严格对应,在go语言中类型不对应不能强行赋值.</p></li><li><p>变量存储:赋值符左边的变量,代表变量所指向的内存 空间</p><p>​ 右边的变量,代表变量内存空间存储的数据值.</p></li><li><p>函数传参传的是引用,其本质是因为new出来的和直接赋值创建的在内存中的存储不一样</p></li></ul></blockquote><p>变量是一种使用方便的占位符，用于引用计算机内存地址。</p><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span>   </span><br><span class="line">   fmt.Printf(<span class="string">"变量的地址: %x\n"</span>, &amp;a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h4><p>一个指针变量指向了一个值的内存地址。</p><p>类似于变量和常量，在使用指针前你需要声明指针.</p><p><code>*p</code>:解引用,间接引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure><h4 id="如何使用指针"><a href="#如何使用指针" class="headerlink" title="如何使用指针"></a>如何使用指针</h4><p>指针使用流程:</p><ul><li>定义指针变量</li><li>为指针变量赋值</li><li>访问指针变量中指向地址的值.</li></ul><p>在指针类型前面加上<code>*</code>(前缀)来获取指针所指的内容.</p><h4 id="Go空指针"><a href="#Go空指针" class="headerlink" title="Go空指针"></a>Go空指针</h4><blockquote><p>空指针和野指针</p><ul><li>空指针是指未被初始化的指针.</li><li>野指针是指被一一片无效的地址初始化的指针.</li></ul></blockquote><p>当一个指针被定义后没有分配任何变量时,它的值为nil.</p><p>nil指针也称为空指针.</p><p>nil在概念上和其他语言的null,Nonen,nil,NULL一样,都指代零值或空值.</p><p>一个指针变量通常缩写为ptr</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">    fmt.Printf(<span class="string">"ptr 的值为 : %x\n"</span>, ptr  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空指针判断:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nil</span>)	<span class="comment">//ptr不是空指针</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">nil</span>)	<span class="comment">//ptr是空指针</span></span><br></pre></td></tr></table></figure><h4 id="GO指针数组"><a href="#GO指针数组" class="headerlink" title="GO指针数组"></a>GO指针数组</h4><p>定义一个指针数组来存储地址</p><p><strong>什么时候需要?</strong></p><ul><li>需要保存数组,这样我们就需要使用到指针数组.</li></ul><h5 id="声明指针数组"><a href="#声明指针数组" class="headerlink" title="声明指针数组"></a>声明指针数组</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr [MAX]*<span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><blockquote><p>创建指针数组的时候,不适合用<code>range</code>循环.</p><p><strong>reason:</strong>这个问题是range循环的实现逻辑引起的.跟for循环不一样的地方在于range循环中的x变量是临时变量.range循环只是将值拷贝到x变量中.因此内存地址都是一样的。</p></blockquote><h4 id="Go语言指向指针的指针"><a href="#Go语言指向指针的指针" class="headerlink" title="Go语言指向指针的指针"></a>Go语言指向指针的指针</h4><p>如果一个指针变量存放的又是另一个指针变量的地址,则称这个指针变量为指向指针的指针变量.</p><h5 id="声明指向指针的指针变量"><a href="#声明指向指针的指针变量" class="headerlink" title="声明指向指针的指针变量"></a>声明指向指针的指针变量</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr **<span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><p>访问时需要使用两个<code>*</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"指向指针的指针变量 **pptr = %d\n"</span>, **pptr)</span><br></pre></td></tr></table></figure><h4 id="Go语言指针作为函数参数"><a href="#Go语言指针作为函数参数" class="headerlink" title="Go语言指针作为函数参数"></a>Go语言指针作为函数参数</h4><blockquote><p>传引用(址传递):将形参的地址值作为函数参数,返回值传递.</p><p>传值:将形参的值拷贝一份给实参</p></blockquote><p>Go语言允许向函数传递指针,只需要在函数定义的参数上设置为指针类型即可.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>,y *<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言结构体"><a href="#Go语言结构体" class="headerlink" title="Go语言结构体"></a>Go语言结构体</h3><p>Go语言中数组可以存储同一类型的数据,但在结构体中我们可以为不同项定义不同的数据类型.</p><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合.</p><blockquote><p>结构体传参:将结构体变量的值拷贝一份,传递. –几乎不用,内存消耗大,效率低.</p><p>结构体变量的地址 == 结构体首个元素的地址</p><p><code>unSafe.Sizeof(变量名)</code>–&gt;此种类型的变量所占用的内存空间.</p></blockquote><h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><p>结构体定义需要使用<code>type</code>和<code>struct</code>语句.<code>struct</code>语句定义一个新的数据类型,结构体中有一个或多个成员.<code>type</code>语句设定了结构体的名称.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">    member definition</span><br><span class="line">    member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦定义了结构体类型,他就能用于变量的声明,语法格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type&#123;value1,value2...valuen&#125;</span><br><span class="line">或</span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure><h4 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h4><p>如果要访问结构体成员,需要使用点号<code>.</code>操作符,格式为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体.成员名</span><br></pre></td></tr></table></figure><h4 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h4><p>可以像其他数据类型一样将结构体类型作为参数传递给函数.并以以上实例的方式访问结构体变量.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">    title <span class="keyword">string</span></span><br><span class="line">    author <span class="keyword">string</span></span><br><span class="line">    subject <span class="keyword">string</span></span><br><span class="line">    book_id <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Book1 Books <span class="comment">//声明Book1为Books类型</span></span><br><span class="line">    </span><br><span class="line">    Book1.title = <span class="string">"Go语言"</span></span><br><span class="line">    Book1.author = <span class="string">"www.runoob.com"</span></span><br><span class="line">   	Book1.subject = <span class="string">"Go 语言教程"</span></span><br><span class="line">   	Book1.book_id = <span class="number">6495407</span></span><br><span class="line"></span><br><span class="line">    printBook(Book1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;</span><br><span class="line">   fmt.Printf( <span class="string">"Book title : %s\n"</span>, book.title)</span><br><span class="line">   fmt.Printf( <span class="string">"Book author : %s\n"</span>, book.author)</span><br><span class="line">   fmt.Printf( <span class="string">"Book subject : %s\n"</span>, book.subject)</span><br><span class="line">   fmt.Printf( <span class="string">"Book book_id : %d\n"</span>, book.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构体指针做函数返回值:不能返回局部 变量的地址值.(局部变量保存在栈帧上,函数调用结束后,栈帧释放,局部变量的地址,不再受系统保护,随时可能分配给其他程序</p></blockquote><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><p>可以定义指向结构体的指针类似其他指针变量,格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure><p>以上定义的指针变量可以存储结构变量的地址.查看结构体变量地址,可以将&amp;符号放置于结构体变量前:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sturct_pointer = &amp;Book1</span><br></pre></td></tr></table></figure><p>使用结构体 指针访问结构体成员,使用”.”操作符:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer.title</span><br></pre></td></tr></table></figure><blockquote><ul><li>结构体是作为参数的值传递</li></ul></blockquote><h4 id="结构体指针做函数返回值"><a href="#结构体指针做函数返回值" class="headerlink" title="结构体指针做函数返回值"></a>结构体指针做函数返回值</h4><p>不能返回局部变量的的地址.–局部变量保存栈帧上,函数调用结束后,栈帧释放,局部变量的地址,不在受系统保护,随时可能分配给其他程序,可以返回局部变量的值.</p><h4 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h4><p>可以通过new函数在在heap上申请一片内存空间,而且不会导致空指针和野指针,简单方便.</p><h3 id="Go语言-切片-Slice"><a href="#Go语言-切片-Slice" class="headerlink" title="Go语言 切片(Slice)"></a>Go语言 切片(Slice)</h3><blockquote><p>为什么使用切片:</p><p>​ 1. 数组容量固定,不能自动拓展</p><pre><code>2. 值传递.数组作为函数参数时,将整个数组值拷贝一份给形参.(在Go语言中我们几乎可以在所有的场景中,使用切片替换数组使用.</code></pre><p>切片的本质:不是一个数组的指针,而是一种数据结构,用来操作数组内部元素.(runtime/slice.go)</p><p>截取数组,初始化切片时,没有指定切片容量时,切片容量跟随原数组(切片).</p></blockquote><p>Go语言切片是对数组的抽象.</p><p>Go数组的长度不可改变,与数组相比切片的长度是不固定的,可以追加元素,在追加时可能使切片的容量增大.</p><h4 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h4><blockquote><p>和数组的区别:创建数组时,[]指定数组长度,创建切片时,[]为空,或者…</p></blockquote><p>你可以声明一个未指定大小的数组来定义切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p><strong>切片不需要说明长度.</strong></p><p>或使用<code>make()</code>函数来创建切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>,<span class="built_in">len</span>)</span><br><span class="line">也可以简写为</span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>也可以指定容量,其中capacity为可选参数.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T,length,capacity)</span><br></pre></td></tr></table></figure><p>这里len是数组的长度并且也是切片的初始长度.</p><h4 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=[] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>直接初始化切片,<code>[]</code>表示是切片类型,{1,2,3}初始化值依次为1,2,3.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure><p>初始化切片s,是数组arr的引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>将arr中从下标<code>startIndex</code>到<code>endIndex-1</code>下的元素创建为一个新的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br></pre></td></tr></table></figure><p>默认 endIndex 时将表示一直到arr的最后一个元素.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br></pre></td></tr></table></figure><p>默认 startIndex 时将表示从arr的第一个元素开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>通过切片s初始化切片s1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>通过内置函数<code>make()</code>初始化切片s,[]int 标识为其元素类型为int的切片</p><h4 id="len-和cap-函数"><a href="#len-和cap-函数" class="headerlink" title="len()和cap()函数"></a>len()和cap()函数</h4><p>切片是可索引的,并且可以由<code>len()</code>方法获取长度.</p><p>切片提供了计算容量的方法<code>cap()</code>可以测量切片最长可以到达多少.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">    printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h4><p>一个切片在未初始化之前默认为nil,长度为0,实例如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">"切片是空的"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>可以通过设置下限及上限来设置截取切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers =="</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[1:4] =="</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[:3] =="</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[4:] =="</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="append-和copy-函数"><a href="#append-和copy-函数" class="headerlink" title="append()和copy()函数"></a>append()和copy()函数</h4><p>如果想增加切片的容量,我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言范围-Range"><a href="#Go语言范围-Range" class="headerlink" title="Go语言范围(Range)"></a>Go语言范围(Range)</h3><p>Go语言中range关键字用于for循环中迭代数组(array),切片(slice),通道(channel)或集合(map)的元素.在数组和切片中返回元素的索引对应的值,在集合中返回key-value对.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"sum:"</span>, sum)</span><br><span class="line">    <span class="comment">//在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符"_"省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"index:"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"apple"</span>, <span class="string">"b"</span>: <span class="string">"banana"</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s -&gt; %s\n"</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">"go"</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言Map-集合"><a href="#Go语言Map-集合" class="headerlink" title="Go语言Map(集合)"></a>Go语言Map(集合)</h3><p>Map是一种无序的键值对的集合.Map最重要的一点是通过key来快速检索数据,key类似于索引,指向数据的值.Map是一种集合,所以我们可以像迭代数组和切片那样迭代它.不过,Map是无序的,我们无法决定它的返回顺序,这是因为Map是使用hash表来实现.</p><blockquote><p>唯一,无序,不能是引用类型数据.</p></blockquote><h4 id="定义Map"><a href="#定义Map" class="headerlink" title="定义Map"></a>定义Map</h4><p>可以使用内建函数make也可以使用map关键字来定义Map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明变量,默认map是nil,不能直接存储key-value</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"><span class="comment">//使用make函数</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure><p>如果不初始化map,那么就会创建一个nil map. nil map不能用来存放键值对.</p><h4 id="dalete-函数"><a href="#dalete-函数" class="headerlink" title="dalete()函数"></a>dalete()函数</h4><p>delete()函数用于删除集合的元素,参数为map和其对应的key.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建map</span></span><br><span class="line">    countryCapitalMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"France"</span>:<span class="string">"Paris"</span>,<span class="string">"Italy"</span>:<span class="string">"Rome"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"原始地图"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印地图</span></span><br><span class="line">    <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap&#123;</span><br><span class="line">        fmt.<span class="built_in">println</span>(country,<span class="string">"首都是"</span>,countryCapitalMap[country])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="built_in">delete</span>(countryCapitalMap,<span class="string">"France"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Fance条目被删除"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言递归函数"><a href="#Go语言递归函数" class="headerlink" title="Go语言递归函数"></a>Go语言递归函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursion</span><span class="params">()</span></span>&#123;</span><br><span class="line">    recursion()	<span class="comment">//函数调用自身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    recursion()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言支持递归.但我们在使用递归时,开发者需要退出条件,否则递归将陷入无限循环中.</p><p>递归函数对于解决数学上的问题是非常有用的,像计算阶乘,生成斐波那契数列等。</p><h4 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factorial</span><span class="params">(n <span class="keyword">uint64</span>)</span><span class="params">(result unit64)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        result = n * Factorial(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言类型转换"><a href="#Go语言类型转换" class="headerlink" title="Go语言类型转换"></a>Go语言类型转换</h3><p>类型转换用于将一种数据类型的变量转换为另一种类型的变量.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure><p>type_name为类型,expression为表达式.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">17</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   	<span class="keyword">var</span> mean <span class="keyword">float32</span></span><br><span class="line">   </span><br><span class="line">   mean = <span class="keyword">float32</span>(sum)/<span class="keyword">float32</span>(count)</span><br><span class="line">   fmt.Printf(<span class="string">"mean 的值为: %f\n"</span>,mean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go语言接口"><a href="#Go语言接口" class="headerlink" title="Go语言接口"></a>Go语言接口</h3><p>Go语言提供另外一种数据类型接口,它把所有的具有共性的方法定义在一起,任何其他类型只要实现了这些方法就实现了这个接口.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">	method_name1 [return_type]</span><br><span class="line">    method_name1 [return_type]</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/*variables*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*实现接口方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go错误处理"><a href="#Go错误处理" class="headerlink" title="Go错误处理"></a>Go错误处理</h3><p>Go语言通过内置的错误接口提供了非常简单的错误处理机制.</p><p>error类型是一个接口类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在编码中通过实现error接口类型来生成错误信息.</p><p>函数通过在最后的返回值中返回错误信息.使用<code>error.New</code>可以返回一个错误信息:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>,error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> f&lt;<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>,error.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>panic与recover</strong></p><p>panic和recover,一个用于主动抛出错误,一个用于捕获panic抛出的错误.</p><p><strong>概念</strong></p><p>panic和 recover是Go的两个内置函数,这两个内置函数用于处理Go运行时的错误,panic用于主动抛出错误,recover用来捕获panic抛出的错误.</p><p>引发panic呦两种情况,一是程序主动调用,二是程序运行是错误,由运行时检测并退出.</p><p>发生panic后,程序会从调用panic的函数位置或发生panic的地方立即返回,逐层向上执行函数的defer语句,然后逐层打印函数调用堆栈,直到被recover捕获或运行到最外层函数.</p><p>panic不但可以在函数正常流程中抛出,在defer逻辑里也可以再次调用或抛出panic.defer里面的panic能够被后续执行的defer捕获.</p><p>recover用来捕获panic,阻止panic继续向上传递.recover()和defer一起使用,但是defer只有在后面的函数体内直接被用掉才能捕获panic终止异常,否则返回nil,异常继续向外传递.</p><p><strong>使用场景</strong></p><p>一般情况下有两种情况用到:</p><ul><li>程序遇到无法执行下去的错误时,抛出错误,主动结束运行.</li><li>在调试程序时,通过panic来打印堆栈,方便定位错误.</li></ul><blockquote><ul><li>1、panic 在没有用 recover 前以及在 recover 捕获那一级函数栈，panic 之后的代码均不会执行；一旦被 recover 捕获后，外层的函数栈代码恢复正常，所有代码均会得到执行；</li><li>2、panic 后，不再执行后面的代码，立即按照逆序执行 defer，并逐级往外层函数栈扩散；defer 就类似 finally；</li><li>3、利用 recover 捕获 panic 时，defer 需要再 panic 之前声明，否则由于 panic 之后的代码得不到执行，因此也无法 recover；</li></ul></blockquote></blockquote><h3 id="Go并发"><a href="#Go并发" class="headerlink" title="Go并发"></a>Go并发</h3><p>Go语言支持必发,我们只需要通过go关键字来开启<code>goroutine</code>即可.</p><p><code>goroutine</code>是轻量级线程,<code>goroutine</code>的调度是由Golang运行时管理的.</p><p><strong>特性</strong>:<strong>主go程结束,子go程随之结束.</strong></p><p><code>goroutine</code>语法格式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名 (参数列表)</span><br></pre></td></tr></table></figure><p>开启一个新的goroutine:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数列表)</span><br></pre></td></tr></table></figure><p>Go允许使用go语句开始一个新的运行期线程,即goroutine,以一个不同的,新创建的<code>goroutine</code>来执行一个函数.同一个程序中所有的<code>gorotine</code>共享同一个地址空间.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">5</span>;i++&#123;</span><br><span class="line">        time.Sleep(<span class="number">100</span>*time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">"world"</span>)</span><br><span class="line">    say(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用函数包"><a href="#常用函数包" class="headerlink" title="常用函数包"></a>常用函数包</h4><h5 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h5><p><code>runtime.Gosched()</code>: 出让当前go程所占用的时间片.当再次获取CPU时,从出让位置继续恢复执行.</p><p> <code>Goexit</code>:终止当前<code>goroutine</code>执行,调度器确保所有已注册<code>defer</code>延迟调用被执行.</p><p><code>GOMAXPROCS</code>:调用runtime.GOMAXPROCS()用来设置可以并行计算的CPU核数的最大值,并返回之前的值.</p><h4 id="通道-channel"><a href="#通道-channel" class="headerlink" title="通道(channel)"></a>通道(channel)</h4><p>通道(channel)是用来传递数据的一个数据结构.</p><p>通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯.操作符<code>&lt;-</code>用于指定通道的方向,发送或接收.如果未指定方向,则为双向通道.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v <span class="comment">//把v发送到通道ch</span></span><br><span class="line">v := &lt;-ch <span class="comment">//从ch接收数据并把值赋值给v</span></span><br></pre></td></tr></table></figure><p>声明一个通道很简单,我们使用<code>chan</code>关键字即可,通道在使用前必须先创建:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>默认情况下,通道是不带缓冲区的.发送端发送数据,同时必须有接收端相应的接收数据.否则阻塞.</p><h5 id="有关方法"><a href="#有关方法" class="headerlink" title="有关方法:"></a>有关方法:</h5><p><code>len(ch)</code>:channel中剩余未读取数据个数</p><p><code>cap(ch)</code>:通道的容量</p><h4 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h4><p>通道可以设置缓冲区,通过make的第二个参数指定缓冲区大小:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态,就是说发送端发送的数据可以放在缓冲区里面,可以等待接收端区获取数据,而不是立刻需要几首端去获取数据.</p><p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p><p><strong>注意</strong>：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><h4 id="Go遍历通道与关闭通道"><a href="#Go遍历通道与关闭通道" class="headerlink" title="Go遍历通道与关闭通道"></a>Go遍历通道与关闭通道</h4><p>Go通过range关键字连实现遍历读取到的数据,类似于数组或切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v,ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 <strong>close()</strong> 函数来关闭。</p><h4 id="单项channel"><a href="#单项channel" class="headerlink" title="单项channel:"></a>单项channel:</h4><p>默认的channel是双向的. <code>var ch chan int</code> <code>ch=make(chan int)</code></p><p>单项写channel : <code>var sendCh chan &lt;- int</code> <code>sendCh = make(chan &lt;-int)</code></p><p>单项读channel : <code>var revCh &lt;- chan int</code> <code>revCh = make(&lt;-chan int)</code></p><p>转换:双向的channel,可以隐式转换为任意一种channel,反之则不行.</p><p>传参:传<em>引用</em></p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>time.Timer是一个定时器,代表未来的一个单一事件,你可以告诉timer你要等待多长时间.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它提供一个channel,在定时时间达到之前,没有数据写入timer.C会一直阻塞.直到定时时间到,系统会自动向timer.C这个channel中写入当前时间,阻塞即被解除.</p><h5 id="三种定时方法"><a href="#三种定时方法" class="headerlink" title="三种定时方法"></a>三种定时方法</h5><ol><li><p>sleep</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(time.second)</span><br></pre></td></tr></table></figure></li><li><p>Time.C</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myTime := time.NewTimer(time.second) <span class="comment">//创建定时器,指定定时时长</span></span><br><span class="line">newTime := &lt;- myTime.C <span class="comment">//定时满,系统写入系统时间</span></span><br></pre></td></tr></table></figure></li><li><p>time.after</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nowTime = &lt;- time.After(time.second)</span><br></pre></td></tr></table></figure></li></ol><h5 id="定时器的停止和重置"><a href="#定时器的停止和重置" class="headerlink" title="定时器的停止和重置"></a>定时器的停止和重置</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTime.Stop()	<span class="comment">//设置定时器停止,将定时器归零</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTime.Reset(time.Second)	<span class="comment">//重置</span></span><br></pre></td></tr></table></figure><h5 id="周期定时器"><a href="#周期定时器" class="headerlink" title="周期定时器"></a>周期定时器</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;- <span class="keyword">chan</span> Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建周期定时器myTicker := time.NewTicker(time.Second)<ul><li>定时时长到达后,系统会自动向Ticker的C中写入系统当前时间.并且,每隔一个定时时长后,循环写入系统当前时间.</li><li>在子go程中循环读取C,获取系统时间.</li></ul></li></ol><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="打开创建文件"><a href="#打开创建文件" class="headerlink" title="打开创建文件"></a>打开创建文件</h4><ol><li>创建文件 Create: 文件不存在创建,文件存在,将文件内容清空<ul><li>参数:name,打开文件的路径:绝对路径,相对路径</li></ul></li><li>打开文件 Open: 以只读方式打开<ul><li>参数:name,打开文件的路径:绝对路径,相对路径</li></ul></li><li>打开文件 OpenFile:以只读,只写,读写方式打开文件<ul><li>参1:name,打开文件路径:角度路径,相对路径</li><li>参2:name,打开文件权限:O_RDONLY,O_ RDWR</li><li>一般传6(读权限,写权限)</li></ul></li></ol><blockquote><p>在文件处理后记得写<code>defer 变量.close()</code>关闭文件</p></blockquote><h4 id="常见的文件读写方式"><a href="#常见的文件读写方式" class="headerlink" title="常见的文件读写方式"></a>常见的文件读写方式</h4><ul><li><p>写文件</p><ul><li>按字符串写: <code>WriteString()</code> –&gt; n:写入的字符个数<ul><li>返回值n,err</li></ul></li><li>按位置写:Seek():修改文件的读写指针位置<ul><li>参1:偏移量(正:想文件尾便宜 负:想文件头偏移)</li><li>参2:偏移的起始位置(io.SeekStart 文件的其实位置,io.SeekCurrent 文件往前的位置,io.SeekEnd 文件结尾位置 )</li><li>返回值:表示从文件起始位置,到当前文件读写指针位置的偏移量</li></ul></li><li>按字节写:writeAt():在文件指定偏移位置,写入[]byte,通常搭配Seek()使用<ul><li>参1:待写入数据</li><li>参2:偏移量</li><li>返回值:实际写出的字节数</li></ul></li></ul></li><li><p>读文件</p><ul><li><p>按行读</p><ol><li><p>创建一个带有缓存区的Reader(读写器)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(打开的文件和指针)</span><br></pre></td></tr></table></figure></li><li><p>从reader的缓冲区中,读取指定长度的数据.数据疮毒取决于 参数 dlime</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.err := reader.Reader.ReadBytes(<span class="string">'\n'</span>);<span class="comment">//按行读</span></span><br></pre></td></tr></table></figure><p>判断到达文件结尾:if err != nil &amp;&amp; err == io.EOF</p></li></ol></li><li><p>按字节读<code>read()</code></p></li></ul></li></ul><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作:"></a>目录操作:</h4><h5 id="打开目录-OpenFile"><a href="#打开目录-OpenFile" class="headerlink" title="打开目录:OpenFile"></a>打开目录:OpenFile</h5><p>以只读,只写,读写方式打开文件,文件不存在则打开失败</p><ul><li>参1:name,打开文件的路径:绝对路径,相对路径</li><li>参2:打开文件权限:O_RDONLY,O_WRONLY,O_RDWR</li><li>参3:ModelDir</li><li>返回值:返回一个可以读写目录的文件指针</li></ul><h5 id="读目录"><a href="#读目录" class="headerlink" title="读目录:"></a>读目录:</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadDir(n,suffer)</span><br></pre></td></tr></table></figure><ul><li><p>参1 : 文件名(欲打开目录项个数,<code>-1</code>表示所有</p></li><li><p>返回值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span>&#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">    Size() <span class="keyword">int64</span></span><br><span class="line">    Model() FileMode</span><br><span class="line">    ModTime() time.Time</span><br><span class="line">    IsDir() <span class="keyword">bool</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><h4 id="select作用"><a href="#select作用" class="headerlink" title="select作用"></a>select作用</h4><p>go里面提供了一个关键字select,通过select可以监听channel上的数据流动.</p><p>select的用法与switch非常相似,由select开始一个性的选择块,每个选择条件由case语句来描述.</p><p>与switch语句相比,select有比较多的限制,其中最大的一条限制就是<strong>每隔case语句里面必须是一个IO操作.</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>:&#123;</span><br><span class="line"><span class="keyword">case</span> chan1 &lt;- <span class="number">1</span>:</span><br><span class="line">	<span class="comment">//如果成功向chan1写入数据,则进行该case处理语句</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">//如果没有成功,则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:</p><ol><li>监听的case中,没有满足监听条件,阻塞.</li><li>监听的case中,有多个满足监听条件,随机一个.</li><li>可以使用default来处理所有case都不满足监听条件的状况.通常不用,会产生忙轮询</li><li>select自身不带有循环机制</li><li>break只能跳出select,类似于switch中的用法.</li></ol></blockquote><h4 id="select-超时处理"><a href="#select-超时处理" class="headerlink" title="select 超时处理"></a>select 超时处理</h4><p>select监听time.After()中channel的读事件.如果定时时间到,系统会向该channel中写入系统当前时间.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- time.After(time.Second*S)</span><br><span class="line">    	定时到达后,要处理内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol><li>单go程自己死锁</li><li>go程间channel访问顺序导致死锁</li><li>多go程,多channel交叉死锁</li><li>在go语言中,尽量不要将互斥锁,读写锁与channel混用 – 隐性死锁</li></ol><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>A,B两个go程共同访问共享数据,由于cpu调度随机,需要对共享数据访问数据加以限定(同步).</p><p>创建mutex(互斥锁),访问共享数据之前,假锁,在Ago程加锁期间,bgo程会加锁失败–阻塞.</p><p>直到Ago程解锁mutex,B从阻塞处,恢复执行.</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读时共享,写时独占.写锁优先级比读锁高.</p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    L Locker</span><br><span class="line">    notify notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数的作用可以归纳为如下三点:</span></span><br><span class="line"><span class="comment">1. 阻塞等待条件变量满足</span></span><br><span class="line"><span class="comment">2.释放已掌握的互斥锁相当于cond.L.unlock() 注意:两步为一个原子操作</span></span><br><span class="line"><span class="comment">3.当被唤醒,Wait函数返回时,解除阻塞并重新获取互斥锁.相当于condLock()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">/*</span></span><br><span class="line"><span class="function">单发通知,给一个正等待<span class="params">(阻塞)</span>在该条件变量上的<span class="title">goroutine</span><span class="params">(线程)</span>发送通知.</span></span><br><span class="line"><span class="function">*/</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">/*</span></span><br><span class="line"><span class="function">广播通知,给正在等待<span class="params">(阻塞)</span>在该条件变量上的所有<span class="title">goroutine</span><span class="params">(线程)</span>发送通知.</span></span><br><span class="line"><span class="function">*/</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li><p>本事不是锁,但经常与锁结合使用</p></li><li><p>使用 流程:</p><ol><li><p>创建 条件变量 :<code>var cond sync.Cond</code></p></li><li><p>指定条件变量用的锁: <code>cond.L = new(sync.Mutex)</code></p></li><li><p><code>cond.L.Lock()</code> 给公共区加锁(互斥量)</p></li><li><p>判断是否到达 阻塞条件 (缓冲区满/空) –for循环判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(ch)==<span class="built_in">cap</span>(ch) &#123;</span><br><span class="line">    cond.Wait()-<span class="number">-1.</span>阻塞 <span class="number">2.</span>解锁 <span class="number">3.</span>加锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问公共区 – 读,写数据,打印</p></li><li><p>解锁条件变量用的锁 cond.L.Unlock()</p></li><li><p>唤醒阻塞在条件变量上的对端.</p></li></ol></li></ul><h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><ul><li>网络通信过程中,socket一定是成对出现的.</li></ul><h4 id="网络分层架构"><a href="#网络分层架构" class="headerlink" title="网络分层架构:"></a>网络分层架构:</h4><p>osi七层模型结构体: 物,数,网,传,会,表,应</p><p>TCP/IP四层模型:数,网,传,应</p><p><strong>各层功能:</strong></p><ul><li>链路层 : ARP<ul><li>源mac——–目标mac</li><li>ARP协议作用:借助IP获取nac地址</li></ul></li><li>网络层 : IP<ul><li>源IP———–目标IP</li><li>IP协议作用:在网络环境中唯一标识一台主机</li><li>IP地址本质:2机制数 —- 点分十进制IP地址(string)</li></ul></li><li>传输层:TCP/UDP<ul><li>port——在一台主机上唯一标识一个进程</li></ul></li><li>应用层:ftp,http,自定义<ul><li>对数据进行封装,解封装</li></ul></li></ul><h4 id="TCP通信过程"><a href="#TCP通信过程" class="headerlink" title="TCP通信过程:"></a>TCP通信过程:</h4><ul><li><p>三次握手:</p><ol><li>主动发起请求端,发送SYN</li><li>被动建立连接请求端,应答ACK同时发送SYN</li><li>主动发起请求端,发送应答ACK</li></ol><ul><li>标准TCP完成三次握手建立完成.–server:Accpet()返回 –client:Dial()返回</li></ul></li></ul><ul><li>四次挥手:<ol><li>主动关闭连接请求端,发送FIN</li><li>被动关闭连接请求端,应答ACK(标志:半关闭完成–close())</li><li>被动关闭连接请求端,发送FIN</li><li>主动关闭连接请求端,应答ACK(标志:四次挥手建立完成.–close())</li></ol></li></ul><h4 id="Server端"><a href="#Server端" class="headerlink" title="Server端:"></a>Server端:</h4><p><strong>TCP-CS服务器步骤</strong>:</p><ol><li>创建监听socket <code>listener := net.Listern(&quot;tcp&quot;,&quot;服务器的IP+port&quot;)</code></li><li>启动监听 <code>conn := listener.Accept()</code> conn用于通信的socket</li><li><code>conn.Read()</code></li><li>处理使用 数据</li><li><code>conn.Write()</code></li><li>关闭listener,conn</li><li></li></ol><ul><li><p><strong>Listen函数</strong>:<code>func Listen(network,address string)(Listener,error)</code></p><p><code>network</code>: 选用的协议:TCP,UDP</p><p><code>address</code>:IP地址+端口号</p></li></ul><ul><li><p><strong>Listen接口</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Listener <span class="keyword">interface</span> &#123;</span><br><span class="line">    Accept()(Conn error)</span><br><span class="line">    Close() error</span><br><span class="line">    Addr() Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Conn接口:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">    Wirte(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err,error)</span><br><span class="line">    Close() error</span><br><span class="line">    LocalAddr() Addr</span><br><span class="line">    RemoteAddr() Addr</span><br><span class="line">    SetDeadline(t time.Time) error</span><br><span class="line">    SetReaddeadline(t time.Time) error</span><br><span class="line">    SetWriteDeadLine(t time.Time) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>一个典型的Go Service段程序大致如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        <span class="comment">//read from the connection</span></span><br><span class="line">        <span class="comment">//write to the connection</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    listen,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8888"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"listen error:"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        conn,err := listen.Accpet()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"accept error:"</span>,err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//start a new goroutine to handle the new connection</span></span><br><span class="line">    	<span class="keyword">go</span> HandleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Client端"><a href="#Client端" class="headerlink" title="Client端:"></a>Client端:</h4><p><strong>TCP-CS客户端</strong></p><ol><li><code>conn,err := net,Dial(&quot;TCP&quot;,服务器的IP+port)</code></li><li>写数据给服务器 服务器 <code>conn.Write()</code></li><li>读取服务器回发的数据 <code>conn.Read()</code></li><li><code>conn.Close()</code></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//指定服务器的IP+port创建,通信套接字</span></span><br><span class="line">   conn,err:=net.Dial(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"net.Dial err:"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.<span class="built_in">close</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主动写数据给服务器</span></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(<span class="string">"Are you ready"</span>))</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">4096</span>)</span><br><span class="line">    <span class="comment">//接收服务器回发数据</span></span><br><span class="line">    n,err := conn.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn.Write(buf[n])</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h4><p><strong>TCP-CS并发服务器步骤</strong>:</p><ol><li>创建监听socket <code>listener := net.Listern(&quot;tcp&quot;,&quot;服务器的IP+port&quot;)</code></li><li><code>defer listener.Close()</code></li><li>for循环阻塞监听 客户端连接事件 <code>conn :=listener.Accept()</code></li><li>创建 go程 对应每一个 客户端进行数据通信 <code>go HandlerConnect()</code></li><li>实现 <code>HandlerConnet(conn net.Conn)</code><ol><li><code>defer conn.Close()</code></li><li>获取成功连接的客户端Addr <code>conn.RemoteAddr()</code></li><li>for 循环 读取 客户端发送数据 <code>conn.Read(buf)</code></li><li>除了数据</li><li>回写转化后的数据 <code>conn.Write([:n])</code></li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandlerConnect</span><span class="params">(conn net.Conn)</span></span>&#123;</span><br><span class="line">     <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    <span class="comment">//获取连接的客户端 Addr</span></span><br><span class="line">    addr := conn.RemoteAddr()</span><br><span class="line">    fmt.Println(addr,<span class="string">"客户端成功连接!"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据通信</span></span><br><span class="line">    <span class="comment">//循环读取客户端发送的数据</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        	fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line">    		<span class="keyword">return</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">//处理并回写</span></span><br><span class="line">        conn.Write([]<span class="keyword">byte</span>(strings.ToUpper(<span class="keyword">string</span>(buf[:n]))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建监听套接字</span></span><br><span class="line">  	listener,err:=net.Listen(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8001"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监听客户端连接请求</span></span><br><span class="line">    conn,err := litener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"litener.Accept err:"</span>,err)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//具体完成服务器和客户端的数据通信</span></span><br><span class="line">    <span class="keyword">go</span> HandlerConnect(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h4><ul><li>无连接,不可靠的报文传递.</li></ul><p><strong>步骤:</strong></p><ol><li>创建用于通信的socket</li><li>阻塞读socket</li><li>处理读到的数据</li><li>写数据给客户端</li></ol><p><strong>相关函数:</strong></p><p>创建监听地址:<code>ResolveUDPAddr(network,address string)(*UDPAddr,error)</code></p><p>创建用于通信的socket:<code>ListenUDP(network string,laddr *UDPaddr) (*UDPConn,error)</code></p><p>接收udp数据:<code>func (c *UDPConn) ReadFromUDP(b []byte) (int,*UDPAddr,error)</code></p><p>写出数据到UDP:<code>func (c *UDPConn) WriteToUDP(b []byte,addr *UDPAddr) (int error)</code></p><p><strong>举个栗子:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">		<span class="string">"net"</span></span><br><span class="line">    	<span class="string">"fmt"</span></span><br><span class="line">    	<span class="string">"time"</span></span><br><span class="line">		)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//组织一个UDP的地址结构,指定服务器的ip和端口 </span></span><br><span class="line">    srvAddr,err := net.ResolveAddr(<span class="string">"udp"</span>,<span class="string">"127.0.0.1:8003"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"ResovleUDPAddr err:"</span>,err )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建用户通信的socket</span></span><br><span class="line">    udpConn,err := net.ListenUDP(<span class="string">"udp"</span>,srvAddr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"ListenUDP err:"</span>,err )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> udpConn.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">4096</span>)</span><br><span class="line">    <span class="comment">//返回三个值:读取到的字节数,客户端的地址,error</span></span><br><span class="line">    n,cltAddr,err := udpConn.ReadFromUDP(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"ReadFromUDP err:"</span>,err )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟处理</span></span><br><span class="line">    fmt.Printf(<span class="string">"服务器读到%v的数据%s\n:"</span>,cltAddr,<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//回写数据给客户端</span></span><br><span class="line">    daytime := time.Now().Stirng()</span><br><span class="line">    udpConn.WriteToUDP([]<span class="keyword">byte</span>(daytime),cltAddr)</span><br><span class="line">    _,err = udpConn.WriteToUDP([]<span class="keyword">byte</span>(daytime),cltAddr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(WriteToUDP err:<span class="string">",err )</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="TCP和UDP比较"><a href="#TCP和UDP比较" class="headerlink" title="TCP和UDP比较"></a>TCP和UDP比较</h4><table><thead><tr><th align="center"></th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">稳定,安全,有序</td><td align="center">效率高,开销小.开发复杂度低</td></tr><tr><td align="center">缺点</td><td align="center">效率低,开销大,复杂难度高</td><td align="center">稳定性差,安全低,无需</td></tr><tr><td align="center">使用场景</td><td align="center">对数据传输安全性高要求的情况</td><td align="center">对数据实时要求较高的情况</td></tr></tbody></table></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 上课睡觉觉</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://robotwuyun.github.io/2020/04/28/学习笔记_Go语言/" title="GoLang学习笔记">https://robotwuyun.github.io/2020/04/28/学习笔记_Go语言/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/学习笔记/" rel="tag"><i class="fa fa-tag"></i> # 学习笔记</a><a href="/tags/go/" rel="tag"><i class="fa fa-tag"></i> # go</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/04/18/学习笔记_nginx/" rel="next" title="nginx入门"><i class="fa fa-chevron-left"></i> nginx入门</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <a href="/"><img class="site-author-image" itemprop="image" src="/image/headPic.png" alt="上课睡觉觉"></a><p class="site-author-name" itemprop="name">上课睡觉觉</p><div class="site-description motion-element" itemprop="description">keep learning</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">78</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">56</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/RobotWuYun" title="GitHub &rarr; https://github.com/RobotWuYun" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://how2j.cn/" title="http://how2j.cn/" rel="noopener" target="_blank">java</a></li><li class="links-of-blogroll-item"> <a href="http://blog.knownsec.com/Knownsec_RD_Checklist/index.html" title="http://blog.knownsec.com/Knownsec_RD_Checklist/index.html" rel="noopener" target="_blank">知道创宇技能树</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言的起源"><span class="nav-number">1.</span> <span class="nav-text">Go语言的起源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言特点"><span class="nav-number">2.</span> <span class="nav-text">Go语言特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GoLang的学习方向"><span class="nav-number">3.</span> <span class="nav-text">GoLang的学习方向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用领域"><span class="nav-number">4.</span> <span class="nav-text">应用领域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置环境变量"><span class="nav-number">5.</span> <span class="nav-text">配置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言快速入门"><span class="nav-number">6.</span> <span class="nav-text">Go语言快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hello-world"><span class="nav-number">6.1.</span> <span class="nav-text">hello world</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go程序开发注意事项"><span class="nav-number">7.</span> <span class="nav-text">Go程序开发注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言基础语法"><span class="nav-number">8.</span> <span class="nav-text">Go语言基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Go标记"><span class="nav-number">8.1.</span> <span class="nav-text">Go标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行分隔符"><span class="nav-number">8.2.</span> <span class="nav-text">行分隔符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标识符"><span class="nav-number">8.3.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串链接"><span class="nav-number">8.4.</span> <span class="nav-text">字符串链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go语言的空格"><span class="nav-number">8.5.</span> <span class="nav-text">Go语言的空格</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言数据类型"><span class="nav-number">9.</span> <span class="nav-text">Go语言数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数字类型"><span class="nav-number">9.1.</span> <span class="nav-text">数字类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#浮点型"><span class="nav-number">9.1.1.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他数字类型"><span class="nav-number">9.1.2.</span> <span class="nav-text">其他数字类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言变量"><span class="nav-number">10.</span> <span class="nav-text">Go语言变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量声明"><span class="nav-number">10.1.</span> <span class="nav-text">变量声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多变量声明"><span class="nav-number">10.1.1.</span> <span class="nav-text">多变量声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#值类型和引用类型"><span class="nav-number">10.1.2.</span> <span class="nav-text">值类型和引用类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简短形式-使用-赋值操作符"><span class="nav-number">10.1.3.</span> <span class="nav-text">简短形式,使用:=赋值操作符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言常量"><span class="nav-number">11.</span> <span class="nav-text">Go语言常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iota"><span class="nav-number">11.1.</span> <span class="nav-text">iota</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言运算符"><span class="nav-number">12.</span> <span class="nav-text">Go语言运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#算数运算符"><span class="nav-number">12.1.</span> <span class="nav-text">算数运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关系运算符"><span class="nav-number">12.2.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑运算符"><span class="nav-number">12.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位运算符"><span class="nav-number">12.4.</span> <span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#赋值运算符"><span class="nav-number">12.5.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他运算符"><span class="nav-number">12.6.</span> <span class="nav-text">其他运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符优先级"><span class="nav-number">12.7.</span> <span class="nav-text">运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言条件语句"><span class="nav-number">13.</span> <span class="nav-text">Go语言条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#if语句"><span class="nav-number">13.1.</span> <span class="nav-text">if语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if-else语句"><span class="nav-number">13.2.</span> <span class="nav-text">if-else语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if嵌套语句"><span class="nav-number">13.3.</span> <span class="nav-text">if嵌套语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch语句"><span class="nav-number">13.4.</span> <span class="nav-text">switch语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Type-Switch"><span class="nav-number">13.4.1.</span> <span class="nav-text">Type Switch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fallthrough"><span class="nav-number">13.4.2.</span> <span class="nav-text">fallthrough</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select语句"><span class="nav-number">13.5.</span> <span class="nav-text">select语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言循环语句"><span class="nav-number">14.</span> <span class="nav-text">Go语言循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for循环"><span class="nav-number">14.1.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环嵌套"><span class="nav-number">14.2.</span> <span class="nav-text">循环嵌套</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环控制语句"><span class="nav-number">14.3.</span> <span class="nav-text">循环控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#break语句"><span class="nav-number">14.3.1.</span> <span class="nav-text">break语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#continue语句"><span class="nav-number">14.3.2.</span> <span class="nav-text">continue语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#goto语句"><span class="nav-number">14.3.3.</span> <span class="nav-text">goto语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无限循环"><span class="nav-number">14.3.4.</span> <span class="nav-text">无限循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言函数"><span class="nav-number">15.</span> <span class="nav-text">Go语言函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数定义"><span class="nav-number">15.1.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数返回多个值"><span class="nav-number">15.2.</span> <span class="nav-text">函数返回多个值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数"><span class="nav-number">15.3.</span> <span class="nav-text">函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数用法"><span class="nav-number">15.4.</span> <span class="nav-text">函数用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言变量作用域"><span class="nav-number">16.</span> <span class="nav-text">Go语言变量作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量"><span class="nav-number">16.1.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局变量"><span class="nav-number">16.2.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#形式参数"><span class="nav-number">16.3.</span> <span class="nav-text">形式参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化局部和全局变量"><span class="nav-number">16.4.</span> <span class="nav-text">初始化局部和全局变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言数组"><span class="nav-number">17.</span> <span class="nav-text">Go语言数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明数组"><span class="nav-number">17.1.</span> <span class="nav-text">声明数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化数组"><span class="nav-number">17.2.</span> <span class="nav-text">初始化数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问数组元素"><span class="nav-number">17.3.</span> <span class="nav-text">访问数组元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多维数组"><span class="nav-number">17.4.</span> <span class="nav-text">多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化二维数组"><span class="nav-number">17.4.1.</span> <span class="nav-text">初始化二维数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向函数传递数组"><span class="nav-number">17.5.</span> <span class="nav-text">向函数传递数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言指针"><span class="nav-number">18.</span> <span class="nav-text">Go语言指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是指针"><span class="nav-number">18.1.</span> <span class="nav-text">什么是指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何使用指针"><span class="nav-number">18.2.</span> <span class="nav-text">如何使用指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go空指针"><span class="nav-number">18.3.</span> <span class="nav-text">Go空指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GO指针数组"><span class="nav-number">18.4.</span> <span class="nav-text">GO指针数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#声明指针数组"><span class="nav-number">18.4.1.</span> <span class="nav-text">声明指针数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go语言指向指针的指针"><span class="nav-number">18.5.</span> <span class="nav-text">Go语言指向指针的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#声明指向指针的指针变量"><span class="nav-number">18.5.1.</span> <span class="nav-text">声明指向指针的指针变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go语言指针作为函数参数"><span class="nav-number">18.6.</span> <span class="nav-text">Go语言指针作为函数参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言结构体"><span class="nav-number">19.</span> <span class="nav-text">Go语言结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义结构体"><span class="nav-number">19.1.</span> <span class="nav-text">定义结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问结构体成员"><span class="nav-number">19.2.</span> <span class="nav-text">访问结构体成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体作为函数参数"><span class="nav-number">19.3.</span> <span class="nav-text">结构体作为函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体指针"><span class="nav-number">19.4.</span> <span class="nav-text">结构体指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结构体指针做函数返回值"><span class="nav-number">19.5.</span> <span class="nav-text">结构体指针做函数返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new函数"><span class="nav-number">19.6.</span> <span class="nav-text">new函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言-切片-Slice"><span class="nav-number">20.</span> <span class="nav-text">Go语言 切片(Slice)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义切片"><span class="nav-number">20.1.</span> <span class="nav-text">定义切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#切片初始化"><span class="nav-number">20.2.</span> <span class="nav-text">切片初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#len-和cap-函数"><span class="nav-number">20.3.</span> <span class="nav-text">len()和cap()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空-nil-切片"><span class="nav-number">20.4.</span> <span class="nav-text">空(nil)切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#切片截取"><span class="nav-number">20.5.</span> <span class="nav-text">切片截取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#append-和copy-函数"><span class="nav-number">20.6.</span> <span class="nav-text">append()和copy()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言范围-Range"><span class="nav-number">21.</span> <span class="nav-text">Go语言范围(Range)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言Map-集合"><span class="nav-number">22.</span> <span class="nav-text">Go语言Map(集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义Map"><span class="nav-number">22.1.</span> <span class="nav-text">定义Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dalete-函数"><span class="nav-number">22.2.</span> <span class="nav-text">dalete()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言递归函数"><span class="nav-number">23.</span> <span class="nav-text">Go语言递归函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#阶乘"><span class="nav-number">23.1.</span> <span class="nav-text">阶乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#斐波那契数列"><span class="nav-number">23.2.</span> <span class="nav-text">斐波那契数列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言类型转换"><span class="nav-number">24.</span> <span class="nav-text">Go语言类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go语言接口"><span class="nav-number">25.</span> <span class="nav-text">Go语言接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go错误处理"><span class="nav-number">26.</span> <span class="nav-text">Go错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go并发"><span class="nav-number">27.</span> <span class="nav-text">Go并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用函数包"><span class="nav-number">27.1.</span> <span class="nav-text">常用函数包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#runtime"><span class="nav-number">27.1.1.</span> <span class="nav-text">runtime</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通道-channel"><span class="nav-number">27.2.</span> <span class="nav-text">通道(channel)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#有关方法"><span class="nav-number">27.2.1.</span> <span class="nav-text">有关方法:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通道缓冲区"><span class="nav-number">27.3.</span> <span class="nav-text">通道缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Go遍历通道与关闭通道"><span class="nav-number">27.4.</span> <span class="nav-text">Go遍历通道与关闭通道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单项channel"><span class="nav-number">27.5.</span> <span class="nav-text">单项channel:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定时器"><span class="nav-number">27.6.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#三种定时方法"><span class="nav-number">27.6.1.</span> <span class="nav-text">三种定时方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定时器的停止和重置"><span class="nav-number">27.6.2.</span> <span class="nav-text">定时器的停止和重置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#周期定时器"><span class="nav-number">27.6.3.</span> <span class="nav-text">周期定时器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件操作"><span class="nav-number">28.</span> <span class="nav-text">文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打开创建文件"><span class="nav-number">28.1.</span> <span class="nav-text">打开创建文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的文件读写方式"><span class="nav-number">28.2.</span> <span class="nav-text">常见的文件读写方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录操作"><span class="nav-number">28.3.</span> <span class="nav-text">目录操作:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#打开目录-OpenFile"><span class="nav-number">28.3.1.</span> <span class="nav-text">打开目录:OpenFile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读目录"><span class="nav-number">28.3.2.</span> <span class="nav-text">读目录:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Select"><span class="nav-number">29.</span> <span class="nav-text">Select</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select作用"><span class="nav-number">29.1.</span> <span class="nav-text">select作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-超时处理"><span class="nav-number">29.2.</span> <span class="nav-text">select 超时处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">30.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥锁"><span class="nav-number">30.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写锁"><span class="nav-number">30.2.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件变量"><span class="nav-number">30.3.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常见参数"><span class="nav-number">30.3.1.</span> <span class="nav-text">常见参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket编程"><span class="nav-number">31.</span> <span class="nav-text">Socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络分层架构"><span class="nav-number">31.1.</span> <span class="nav-text">网络分层架构:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP通信过程"><span class="nav-number">31.2.</span> <span class="nav-text">TCP通信过程:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Server端"><span class="nav-number">31.3.</span> <span class="nav-text">Server端:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Client端"><span class="nav-number">31.4.</span> <span class="nav-text">Client端:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发服务器"><span class="nav-number">31.5.</span> <span class="nav-text">并发服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP通信"><span class="nav-number">31.6.</span> <span class="nav-text">UDP通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP和UDP比较"><span class="nav-number">31.7.</span> <span class="nav-text">TCP和UDP比较</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas" style=""><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/">ArrayList</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HelloWorld/">HelloWorld</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/">IO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDBC/">JDBC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/">JDK</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JRE/">JRE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Junit/">Junit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/">LinkedList</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Log4j/">Log4j</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/">Servlet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Session/">Session</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/">SpringCloud</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/">Typora</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">35</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lombok/">lombok</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反射机制/">反射机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/变量/">变量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习笔记/">学习笔记</a><span class="tag-list-count">48</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常处理/">异常处理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/控制流程/">控制流程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作符/">操作符</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数字与字符串/">数字与字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数组/">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日期/">日期</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛型/">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解/">注解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类和对象/">类和对象</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程/">线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/练手项目/">练手项目</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/继承与接口/">继承与接口</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/资源/">资源</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合框架/">集合框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面向对象/">面向对象</a><span class="tag-list-count">1</span></li></ul></canvas></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">上课睡觉觉</span> <span class="post-meta-divider">|</span><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共159.4k字</span> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br></div><script>var now=new Date;function createtime(){var n=new Date("6/4/2019 12:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML=" Runing "+dnum+" D ",document.getElementById("times").innerHTML=hnum+" H "+mnum+" M "+snum+" S"}setInterval("createtime()",250)</script><br></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="访客"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/affix.js?v=7.1.2"></script><script src="/js/schemes/pisces.js?v=7.1.2"></script><script src="/js/scrollspy.js?v=7.1.2"></script><script src="/js/post-details.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script><script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return-1<GUEST.indexOf(e)}),new Valine({el:"#comments",verify:!0,notify:!0,appId:"307oukv7PLH0lFI21FdIyLQN-gzGzoHsz",appKey:"OxpbXXBsre8puGriAb0RuF3Y",placeholder:"欢迎交流讨论...",avatar:"mm",meta:guest,pageSize:"10",visitor:!1,lang:"zh-cn"})</script><script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + '')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': '',
                'X-LC-Key': '',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},log:!1})</script></body></html>